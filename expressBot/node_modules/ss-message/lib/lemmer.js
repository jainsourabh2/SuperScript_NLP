'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _wordpos = require('wordpos');

var _wordpos2 = _interopRequireDefault(_wordpos);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const wordpos = new _wordpos2.default({ stopwords: false });

const isLetter = test => test.toLowerCase() !== test.toUpperCase();

const getPossibleForms = function getPossibleForms(word, pos) {
  const forms = [word];
  if (pos === 'n') {
    if (word.endsWith('s')) {
      forms.push(word.slice(0, -1));
    } else if (word.endsWith('ses')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('xes')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('zes')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('ches')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('shes')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('men')) {
      forms.push(`${ word.slice(0, -3) }man`);
    } else if (word.endsWith('ies')) {
      forms.push(`${ word.slice(0, -3) }y`);
    }
  } else if (pos === 'v') {
    if (word.endsWith('s')) {
      forms.push(word.slice(0, -1));
    } else if (word.endsWith('ies')) {
      forms.push(`${ word.slice(0, -3) }y`);
    } else if (word.endsWith('es')) {
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('ed')) {
      forms.push(word.slice(0, -1));
      forms.push(word.slice(0, -2));
    } else if (word.endsWith('ing')) {
      forms.push(`${ word.slice(0, -3) }e`);
      forms.push(word.slice(0, -3));
    }
  } else if (pos === 'r') {
    if (word.endsWith('er')) {
      forms.push(word.slice(0, -2));
      forms.push(word.slice(0, -1));
    } else if (word.endsWith('est')) {
      forms.push(word.slice(0, -3));
      forms.push(word.slice(0, -2));
    }
  }
  return forms;
};

const checkExists = (() => {
  var _ref = _asyncToGenerator(function* (word, pos) {
    if (pos === 'n') {
      return (yield wordpos.lookupNoun(word)) ? word : null;
    } else if (pos === 'v') {
      return (yield wordpos.lookupVerb(word)) ? word : null;
    } else if (pos === 'a') {
      return (yield wordpos.lookupAdjective(word)) ? word : null;
    } else if (pos === 'r') {
      return (yield wordpos.lookupAdverb(word)) ? word : null;
    }
    return null;
  });

  return function checkExists(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

const forms = (() => {
  var _ref2 = _asyncToGenerator(function* (term, posTags = ['n', 'v', 'a', 'r']) {
    const possibleForms = posTags.map(function (pos) {
      return { pos, forms: getPossibleForms(term, pos) };
    });
    console.log('possible forms', possibleForms);
    let results = yield Promise.all(possibleForms.map(function (possibleForm) {
      return Promise.all(possibleForm.forms.map(function (form) {
        return checkExists(form, possibleForm.pos);
      }));
    }));
    console.log('results', results);
    results = _lodash2.default.filter(_lodash2.default.flatten(results), function (result) {
      return result;
    });
    return results;
  });

  function forms(_x3) {
    return _ref2.apply(this, arguments);
  }

  return forms;
})();

const processTerm = (() => {
  var _ref3 = _asyncToGenerator(function* (term) {
    if (!isLetter(term.charAt(0))) {
      return term;
    }

    console.log((yield wordpos.lookup('pineapple')));

    var _term$split = term.split('#'),
        _term$split2 = _slicedToArray(_term$split, 2);

    const cleanTerm = _term$split2[0],
          pos = _term$split2[1];

    const results = yield forms(cleanTerm, pos ? [pos] : undefined);

    if (results.length === 0) {
      return term;
    }

    let wordForms = results.map(function (form) {
      return form.split('#')[0];
    });
    wordForms = _lodash2.default.uniq(wordForms);

    return _lodash2.default.reduce(wordForms, function (memo, word) {
      return memo.length < word.length ? memo : word;
    });
  });

  function processTerm(_x4) {
    return _ref3.apply(this, arguments);
  }

  return processTerm;
})();

const lemmatize = (() => {
  var _ref4 = _asyncToGenerator(function* (input = [], cb) {
    console.log(input);
    const lookup = _lodash2.default.isString(input) ? [input] : input;
    let result;
    try {
      result = yield Promise.all(lookup.map(function (term) {
        return processTerm(term);
      }));
    } catch (err) {
      console.log(err);
    }
    return cb(null, result);
  });

  function lemmatize() {
    return _ref4.apply(this, arguments);
  }

  return lemmatize;
})();

exports.default = { lemmatize };